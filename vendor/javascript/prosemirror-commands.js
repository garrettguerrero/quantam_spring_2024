import{liftTarget as e,replaceStep as t,ReplaceStep as r,canJoin as n,joinPoint as o,canSplit as l,ReplaceAroundStep as i,findWrapping as s}from"prosemirror-transform";import{Slice as c,Fragment as f}from"prosemirror-model";import{NodeSelection as a,Selection as p,TextSelection as u,AllSelection as d}from"prosemirror-state";const deleteSelection=(e,t)=>{if(e.selection.empty)return false;t&&t(e.tr.deleteSelection().scrollIntoView());return true};function atBlockStart(e,t){let{$cursor:r}=e.selection;return!r||(t?!t.endOfTextblock("backward",e):r.parentOffset>0)?null:r}const joinBackward=(r,n,o)=>{let l=atBlockStart(r,o);if(!l)return false;let i=findCutBefore(l);if(!i){let t=l.blockRange(),o=t&&e(t);if(null==o)return false;n&&n(r.tr.lift(t,o).scrollIntoView());return true}let s=i.nodeBefore;if(!s.type.spec.isolating&&deleteBarrier(r,i,n))return true;if(0==l.parent.content.size&&(textblockAt(s,"end")||a.isSelectable(s))){let e=t(r.doc,l.before(),l.after(),c.empty);if(e&&e.slice.size<e.to-e.from){if(n){let t=r.tr.step(e);t.setSelection(textblockAt(s,"end")?p.findFrom(t.doc.resolve(t.mapping.map(i.pos,-1)),-1):a.create(t.doc,i.pos-s.nodeSize));n(t.scrollIntoView())}return true}}if(s.isAtom&&i.depth==l.depth-1){n&&n(r.tr.delete(i.pos-s.nodeSize,i.pos).scrollIntoView());return true}return false};const joinTextblockBackward=(e,t,r)=>{let n=atBlockStart(e,r);if(!n)return false;let o=findCutBefore(n);return!!o&&joinTextblocksAround(e,o,t)};const joinTextblockForward=(e,t,r)=>{let n=atBlockEnd(e,r);if(!n)return false;let o=findCutAfter(n);return!!o&&joinTextblocksAround(e,o,t)};function joinTextblocksAround(e,n,o){let l=n.nodeBefore,i=l,s=n.pos-1;for(;!i.isTextblock;s--){if(i.type.spec.isolating)return false;let e=i.lastChild;if(!e)return false;i=e}let f=n.nodeAfter,a=f,p=n.pos+1;for(;!a.isTextblock;p++){if(a.type.spec.isolating)return false;let e=a.firstChild;if(!e)return false;a=e}let d=t(e.doc,s,p,c.empty);if(!d||d.from!=s||d instanceof r&&d.slice.size>=p-s)return false;if(o){let t=e.tr.step(d);t.setSelection(u.create(t.doc,s));o(t.scrollIntoView())}return true}function textblockAt(e,t,r=false){for(let n=e;n;n="start"==t?n.firstChild:n.lastChild){if(n.isTextblock)return true;if(r&&1!=n.childCount)return false}return false}const selectNodeBackward=(e,t,r)=>{let{$head:n,empty:o}=e.selection,l=n;if(!o)return false;if(n.parent.isTextblock){if(r?!r.endOfTextblock("backward",e):n.parentOffset>0)return false;l=findCutBefore(n)}let i=l&&l.nodeBefore;if(!i||!a.isSelectable(i))return false;t&&t(e.tr.setSelection(a.create(e.doc,l.pos-i.nodeSize)).scrollIntoView());return true};function findCutBefore(e){if(!e.parent.type.spec.isolating)for(let t=e.depth-1;t>=0;t--){if(e.index(t)>0)return e.doc.resolve(e.before(t+1));if(e.node(t).type.spec.isolating)break}return null}function atBlockEnd(e,t){let{$cursor:r}=e.selection;return!r||(t?!t.endOfTextblock("forward",e):r.parentOffset<r.parent.content.size)?null:r}const joinForward=(e,r,n)=>{let o=atBlockEnd(e,n);if(!o)return false;let l=findCutAfter(o);if(!l)return false;let i=l.nodeAfter;if(deleteBarrier(e,l,r))return true;if(0==o.parent.content.size&&(textblockAt(i,"start")||a.isSelectable(i))){let n=t(e.doc,o.before(),o.after(),c.empty);if(n&&n.slice.size<n.to-n.from){if(r){let t=e.tr.step(n);t.setSelection(textblockAt(i,"start")?p.findFrom(t.doc.resolve(t.mapping.map(l.pos)),1):a.create(t.doc,t.mapping.map(l.pos)));r(t.scrollIntoView())}return true}}if(i.isAtom&&l.depth==o.depth-1){r&&r(e.tr.delete(l.pos,l.pos+i.nodeSize).scrollIntoView());return true}return false};const selectNodeForward=(e,t,r)=>{let{$head:n,empty:o}=e.selection,l=n;if(!o)return false;if(n.parent.isTextblock){if(r?!r.endOfTextblock("forward",e):n.parentOffset<n.parent.content.size)return false;l=findCutAfter(n)}let i=l&&l.nodeAfter;if(!i||!a.isSelectable(i))return false;t&&t(e.tr.setSelection(a.create(e.doc,l.pos)).scrollIntoView());return true};function findCutAfter(e){if(!e.parent.type.spec.isolating)for(let t=e.depth-1;t>=0;t--){let r=e.node(t);if(e.index(t)+1<r.childCount)return e.doc.resolve(e.after(t+1));if(r.type.spec.isolating)break}return null}const joinUp=(e,t)=>{let r,l=e.selection,i=l instanceof a;if(i){if(l.node.isTextblock||!n(e.doc,l.from))return false;r=l.from}else{r=o(e.doc,l.from,-1);if(null==r)return false}if(t){let n=e.tr.join(r);i&&n.setSelection(a.create(n.doc,r-e.doc.resolve(r).nodeBefore.nodeSize));t(n.scrollIntoView())}return true};const joinDown=(e,t)=>{let r,l=e.selection;if(l instanceof a){if(l.node.isTextblock||!n(e.doc,l.to))return false;r=l.to}else{r=o(e.doc,l.to,1);if(null==r)return false}t&&t(e.tr.join(r).scrollIntoView());return true};const lift=(t,r)=>{let{$from:n,$to:o}=t.selection;let l=n.blockRange(o),i=l&&e(l);if(null==i)return false;r&&r(t.tr.lift(l,i).scrollIntoView());return true};const newlineInCode=(e,t)=>{let{$head:r,$anchor:n}=e.selection;if(!r.parent.type.spec.code||!r.sameParent(n))return false;t&&t(e.tr.insertText("\n").scrollIntoView());return true};function defaultBlockAt(e){for(let t=0;t<e.edgeCount;t++){let{type:r}=e.edge(t);if(r.isTextblock&&!r.hasRequiredAttrs())return r}return null}const exitCode=(e,t)=>{let{$head:r,$anchor:n}=e.selection;if(!r.parent.type.spec.code||!r.sameParent(n))return false;let o=r.node(-1),l=r.indexAfter(-1),i=defaultBlockAt(o.contentMatchAt(l));if(!i||!o.canReplaceWith(l,l,i))return false;if(t){let n=r.after(),o=e.tr.replaceWith(n,n,i.createAndFill());o.setSelection(p.near(o.doc.resolve(n),1));t(o.scrollIntoView())}return true};const createParagraphNear=(e,t)=>{let r=e.selection,{$from:n,$to:o}=r;if(r instanceof d||n.parent.inlineContent||o.parent.inlineContent)return false;let l=defaultBlockAt(o.parent.contentMatchAt(o.indexAfter()));if(!l||!l.isTextblock)return false;if(t){let r=(!n.parentOffset&&o.index()<o.parent.childCount?n:o).pos;let i=e.tr.insert(r,l.createAndFill());i.setSelection(u.create(i.doc,r+1));t(i.scrollIntoView())}return true};const liftEmptyBlock=(t,r)=>{let{$cursor:n}=t.selection;if(!n||n.parent.content.size)return false;if(n.depth>1&&n.after()!=n.end(-1)){let e=n.before();if(l(t.doc,e)){r&&r(t.tr.split(e).scrollIntoView());return true}}let o=n.blockRange(),i=o&&e(o);if(null==i)return false;r&&r(t.tr.lift(o,i).scrollIntoView());return true};function splitBlockAs(e){return(t,r)=>{let{$from:n,$to:o}=t.selection;if(t.selection instanceof a&&t.selection.node.isBlock){if(!n.parentOffset||!l(t.doc,n.pos))return false;r&&r(t.tr.split(n.pos).scrollIntoView());return true}if(!n.parent.isBlock)return false;if(r){let i=o.parentOffset==o.parent.content.size;let s=t.tr;(t.selection instanceof u||t.selection instanceof d)&&s.deleteSelection();let c=0==n.depth?null:defaultBlockAt(n.node(-1).contentMatchAt(n.indexAfter(-1)));let f=e&&e(o.parent,i);let a=f?[f]:i&&c?[{type:c}]:void 0;let p=l(s.doc,s.mapping.map(n.pos),1,a);if(!a&&!p&&l(s.doc,s.mapping.map(n.pos),1,c?[{type:c}]:void 0)){c&&(a=[{type:c}]);p=true}if(p){s.split(s.mapping.map(n.pos),1,a);if(!i&&!n.parentOffset&&n.parent.type!=c){let e=s.mapping.map(n.before()),t=s.doc.resolve(e);c&&n.node(-1).canReplaceWith(t.index(),t.index()+1,c)&&s.setNodeMarkup(s.mapping.map(n.before()),c)}}r(s.scrollIntoView())}return true}}const m=splitBlockAs();const splitBlockKeepMarks=(e,t)=>m(e,t&&(r=>{let n=e.storedMarks||e.selection.$to.parentOffset&&e.selection.$from.marks();n&&r.ensureMarks(n);t(r)}));const selectParentNode=(e,t)=>{let r,{$from:n,to:o}=e.selection;let l=n.sharedDepth(o);if(0==l)return false;r=n.before(l);t&&t(e.tr.setSelection(a.create(e.doc,r)));return true};const selectAll=(e,t)=>{t&&t(e.tr.setSelection(new d(e.doc)));return true};function joinMaybeClear(e,t,r){let o=t.nodeBefore,l=t.nodeAfter,i=t.index();if(!o||!l||!o.type.compatibleContent(l.type))return false;if(!o.content.size&&t.parent.canReplace(i-1,i)){r&&r(e.tr.delete(t.pos-o.nodeSize,t.pos).scrollIntoView());return true}if(!t.parent.canReplace(i,i+1)||!(l.isTextblock||n(e.doc,t.pos)))return false;r&&r(e.tr.clearIncompatible(t.pos,o.type,o.contentMatchAt(o.childCount)).join(t.pos).scrollIntoView());return true}function deleteBarrier(t,r,o){let l,s,a=r.nodeBefore,u=r.nodeAfter;if(a.type.spec.isolating||u.type.spec.isolating)return false;if(joinMaybeClear(t,r,o))return true;let d=r.parent.canReplace(r.index(),r.index()+1);if(d&&(l=(s=a.contentMatchAt(a.childCount)).findWrapping(u.type))&&s.matchType(l[0]||u.type).validEnd){if(o){let e=r.pos+u.nodeSize,s=f.empty;for(let e=l.length-1;e>=0;e--)s=f.from(l[e].create(null,s));s=f.from(a.copy(s));let p=t.tr.step(new i(r.pos-1,e,r.pos,e,new c(s,1,0),l.length,true));let d=e+2*l.length;n(p.doc,d)&&p.join(d);o(p.scrollIntoView())}return true}let m=p.findFrom(r,1);let k=m&&m.$from.blockRange(m.$to),h=k&&e(k);if(null!=h&&h>=r.depth){o&&o(t.tr.lift(k,h).scrollIntoView());return true}if(d&&textblockAt(u,"start",true)&&textblockAt(a,"end")){let e=a,n=[];for(;;){n.push(e);if(e.isTextblock)break;e=e.lastChild}let l=u,s=1;for(;!l.isTextblock;l=l.firstChild)s++;if(e.canReplace(e.childCount,e.childCount,l.content)){if(o){let e=f.empty;for(let t=n.length-1;t>=0;t--)e=f.from(n[t].copy(e));let l=t.tr.step(new i(r.pos-n.length,r.pos+u.nodeSize,r.pos+s,r.pos+u.nodeSize-s,new c(e,n.length,0),0,true));o(l.scrollIntoView())}return true}}return false}function selectTextblockSide(e){return function(t,r){let n=t.selection,o=e<0?n.$from:n.$to;let l=o.depth;while(o.node(l).isInline){if(!l)return false;l--}if(!o.node(l).isTextblock)return false;r&&r(t.tr.setSelection(u.create(t.doc,e<0?o.start(l):o.end(l))));return true}}const k=selectTextblockSide(-1);const h=selectTextblockSide(1);function wrapIn(e,t=null){return function(r,n){let{$from:o,$to:l}=r.selection;let i=o.blockRange(l),c=i&&s(i,e,t);if(!c)return false;n&&n(r.tr.wrap(i,c).scrollIntoView());return true}}function setBlockType(e,t=null){return function(r,n){let o=false;for(let n=0;n<r.selection.ranges.length&&!o;n++){let{$from:{pos:l},$to:{pos:i}}=r.selection.ranges[n];r.doc.nodesBetween(l,i,((n,l)=>{if(o)return false;if(n.isTextblock&&!n.hasMarkup(e,t))if(n.type==e)o=true;else{let t=r.doc.resolve(l),n=t.index();o=t.parent.canReplaceWith(n,n+1,e)}}))}if(!o)return false;if(n){let o=r.tr;for(let n=0;n<r.selection.ranges.length;n++){let{$from:{pos:l},$to:{pos:i}}=r.selection.ranges[n];o.setBlockType(l,i,e,t)}n(o.scrollIntoView())}return true}}function markApplies(e,t,r){for(let n=0;n<t.length;n++){let{$from:o,$to:l}=t[n];let i=0==o.depth&&(e.inlineContent&&e.type.allowsMarkType(r));e.nodesBetween(o.pos,l.pos,(e=>{if(i)return false;i=e.inlineContent&&e.type.allowsMarkType(r)}));if(i)return true}return false}function toggleMark(e,t=null){return function(r,n){let{empty:o,$cursor:l,ranges:i}=r.selection;if(o&&!l||!markApplies(r.doc,i,e))return false;if(n)if(l)e.isInSet(r.storedMarks||l.marks())?n(r.tr.removeStoredMark(e)):n(r.tr.addStoredMark(e.create(t)));else{let o=false,l=r.tr;for(let t=0;!o&&t<i.length;t++){let{$from:n,$to:l}=i[t];o=r.doc.rangeHasMark(n.pos,l.pos,e)}for(let r=0;r<i.length;r++){let{$from:n,$to:s}=i[r];if(o)l.removeMark(n.pos,s.pos,e);else{let r=n.pos,o=s.pos,i=n.nodeAfter,c=s.nodeBefore;let f=i&&i.isText?/^\s*/.exec(i.text)[0].length:0;let a=c&&c.isText?/\s*$/.exec(c.text)[0].length:0;if(r+f<o){r+=f;o-=a}l.addMark(r,o,e.create(t))}}n(l.scrollIntoView())}return true}}function wrapDispatchForJoin(e,t){return r=>{if(!r.isGeneric)return e(r);let o=[];for(let e=0;e<r.mapping.maps.length;e++){let t=r.mapping.maps[e];for(let e=0;e<o.length;e++)o[e]=t.map(o[e]);t.forEach(((e,t,r,n)=>o.push(r,n)))}let l=[];for(let e=0;e<o.length;e+=2){let n=o[e],i=o[e+1];let s=r.doc.resolve(n),c=s.sharedDepth(i),f=s.node(c);for(let e=s.indexAfter(c),r=s.after(c+1);r<=i;++e){let n=f.maybeChild(e);if(!n)break;if(e&&-1==l.indexOf(r)){let o=f.child(e-1);o.type==n.type&&t(o,n)&&l.push(r)}r+=n.nodeSize}}l.sort(((e,t)=>e-t));for(let e=l.length-1;e>=0;e--)n(r.doc,l[e])&&r.join(l[e]);e(r)}}function autoJoin(e,t){let r=Array.isArray(t)?e=>t.indexOf(e.type.name)>-1:t;return(t,n,o)=>e(t,n&&wrapDispatchForJoin(n,r),o)}function chainCommands(...e){return function(t,r,n){for(let o=0;o<e.length;o++)if(e[o](t,r,n))return true;return false}}let b=chainCommands(deleteSelection,joinBackward,selectNodeBackward);let g=chainCommands(deleteSelection,joinForward,selectNodeForward);const x={Enter:chainCommands(newlineInCode,createParagraphNear,liftEmptyBlock,m),"Mod-Enter":exitCode,Backspace:b,"Mod-Backspace":b,"Shift-Backspace":b,Delete:g,"Mod-Delete":g,"Mod-a":selectAll};const y={"Ctrl-h":x.Backspace,"Alt-Backspace":x["Mod-Backspace"],"Ctrl-d":x.Delete,"Ctrl-Alt-Backspace":x["Mod-Delete"],"Alt-Delete":x["Mod-Delete"],"Alt-d":x["Mod-Delete"],"Ctrl-a":k,"Ctrl-e":h};for(let e in x)y[e]=x[e];const A="undefined"!=typeof navigator?/Mac|iP(hone|[oa]d)/.test(navigator.platform):!("undefined"==typeof os||!os.platform)&&"darwin"==os.platform();const w=A?y:x;export{autoJoin,w as baseKeymap,chainCommands,createParagraphNear,deleteSelection,exitCode,joinBackward,joinDown,joinForward,joinTextblockBackward,joinTextblockForward,joinUp,lift,liftEmptyBlock,y as macBaseKeymap,newlineInCode,x as pcBaseKeymap,selectAll,selectNodeBackward,selectNodeForward,selectParentNode,h as selectTextblockEnd,k as selectTextblockStart,setBlockType,m as splitBlock,splitBlockAs,splitBlockKeepMarks,toggleMark,wrapIn};

